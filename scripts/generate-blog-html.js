import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const languages = ['en', 'uk', 'pl'];
const buildDir = path.join(__dirname, '../build');

// Ensure build dir exists
if (!fs.existsSync(buildDir)) {
    fs.mkdirSync(buildDir, { recursive: true });
}

// Read the base index.html template (generated by vite)
const templatePath = path.join(buildDir, 'index.html');
if (!fs.existsSync(templatePath)) {
    console.error('Build index.html not found. Run npm run build first.');
    process.exit(1);
}
const template = fs.readFileSync(templatePath, 'utf8');

languages.forEach(lang => {
    const isDefault = lang === 'en';
    const langPrefix = isDefault ? '' : lang;
    const langDir = isDefault ? buildDir : path.join(buildDir, lang);
    const blogDir = path.join(langDir, 'blog');

    // Ensure output directory exists
    if (!fs.existsSync(blogDir)) {
        fs.mkdirSync(blogDir, { recursive: true });
    }

    // Read blog posts data
    const dataFilename = isDefault ? 'blogPosts.json' : `blogPosts_${lang}.json`;
    const dataPath = path.join(__dirname, `../src/data/${dataFilename}`);

    if (!fs.existsSync(dataPath)) {
        console.warn(`Data file not found for ${lang}: ${dataPath}`);
        return;
    }

    const blogPosts = JSON.parse(fs.readFileSync(dataPath, 'utf8'));

    // Generate HTML for each blog post
    blogPosts.forEach(post => {
        const postDir = path.join(blogDir, post.slug);
        if (!fs.existsSync(postDir)) {
            fs.mkdirSync(postDir, { recursive: true });
        }

        let html = template;

        // 1. Update html lang attribute
        html = html.replace(/<html lang="[^"]*">/, `<html lang="${lang}">`);

        // 2. Update Metadata
        html = html.replace(
            /<title>[\s\S]*?<\/title>/,
            `<title>${post.title} | DealoAgent.ai</title>`
        );

        html = html.replace(
            /<meta name="description"[\s\S]*?\/>/,
            `<meta name="description" content="${post.excerpt}" />`
        );

        // 3. Update OG tags
        html = html.replace(
            /<meta property="og:title"[\s\S]*?\/>/,
            `<meta property="og:title" content="${post.title}" />`
        );
        html = html.replace(
            /<meta property="og:description"[\s\S]*?\/>/,
            `<meta property="og:description" content="${post.excerpt}" />`
        );

        // Fix absolute image URLs if they are relative
        const imageUrl = post.coverImage.startsWith('/')
            ? `https://dealoagent.ai${post.coverImage}`
            : post.coverImage;

        html = html.replace(
            /<meta property="og:image"[\s\S]*?\/>/,
            `<meta property="og:image" content="${imageUrl}" />`
        );

        const canonicalPath = isDefault ? `/blog/${post.slug}/` : `/${lang}/blog/${post.slug}/`;
        const fullUrl = `https://dealoagent.ai${canonicalPath}`;

        html = html.replace(
            /<meta property="og:url"[\s\S]*?\/>/,
            `<meta property="og:url" content="${fullUrl}" />`
        );

        // 4. Update Twitter tags
        html = html.replace(
            /<meta property="twitter:title"[\s\S]*?\/>/,
            `<meta property="twitter:title" content="${post.title}" />`
        );
        html = html.replace(
            /<meta property="twitter:description"[\s\S]*?\/>/,
            `<meta property="twitter:description" content="${post.excerpt}" />`
        );
        html = html.replace(
            /<meta property="twitter:image"[\s\S]*?\/>/,
            `<meta property="twitter:image" content="${imageUrl}" />`
        );
        html = html.replace(
            /<meta property="twitter:url"[\s\S]*?\/>/,
            `<meta property="twitter:url" content="${fullUrl}" />`
        );

        // 5. Canonical and Hreflang
        // Remove existing canonical
        html = html.replace(/<link rel="canonical"[\s\S]*?\/>/, '');

        // Remove existing hreflangs if any (unlikely in template but good practice)
        // html = html.replace(/<link rel="alternate" hreflang=... />/g, ''); 

        // Construct new tags
        let seoTags = `<link rel="canonical" href="${fullUrl}" />\n`;

        languages.forEach(l => {
            const lPrefix = l === 'en' ? '' : `/${l}`;
            const lUrl = `https://dealoagent.ai${lPrefix}/blog/${post.slug}/`; // Assuming slug is same across languages or we need a map. 
            // Note: If slugs are translated, we need a way to map them. 
            // For now assuming same slug. If user translates slug, he needs to update id/slug in json.
            // But if slugs are different, we can't easily cross-link without an ID map.
            // Current Plan: Use same slug, or rely on ID to find counterpart?
            // With separate JSON files, it's hard to match.
            // Simplified approach: Link to same slug. If 404, that's a content issue.
            seoTags += `    <link rel="alternate" hreflang="${l}" href="${lUrl}" />\n`;
        });

        // Add x-default
        seoTags += `    <link rel="alternate" hreflang="x-default" href="https://dealoagent.ai/blog/${post.slug}/" />`;

        // Inject into head
        html = html.replace(/<\/head>/, `${seoTags}\n  </head>`);

        // 6. Inject Content (Server Side Rendering Simulation)
        const renderData = (content) => {
            return content.map(block => {
                switch (block.type) {
                    case 'paragraph': return `<p>${block.text}</p>`;
                    case 'heading': return `<h${block.level}>${block.text}</h${block.level}>`;
                    case 'list': return `<ul>${block.items.map(i => `<li>${i}</li>`).join('')}</ul>`;
                    default: return '';
                }
            }).join('\n');
        };

        // Just inject title for now as full content rendering is complex and React hydrates it anyway. 
        // This is mainly for SEO text availability.
        const postHtmlContent = `
            <div style="display:none; visibility:hidden;">
                <h1>${post.title}</h1>
                <p>${post.excerpt}</p>
                ${renderData(post.content || [])}
            </div>
        `;

        // Inject into root or body
        html = html.replace(
            /<div id="root"><\/div>/,
            `<div id="root">${postHtmlContent}</div>`
        );

        fs.writeFileSync(path.join(postDir, 'index.html'), html);
        console.log(`✓ Generated: ${langPrefix}/blog/${post.slug}/index.html`);

        // Also create a .html file at the blog directory level (e.g. blog/slug.html)
        // This prevents GitHub Pages from issuing a 301 redirect when the URL
        // is requested without a trailing slash (e.g. /blog/slug -> /blog/slug/)
        // GitHub Pages resolves /blog/slug to blog/slug.html directly (200)
        const htmlFilePath = path.join(blogDir, `${post.slug}.html`);
        fs.writeFileSync(htmlFilePath, html);
        console.log(`✓ Generated: ${langPrefix}/blog/${post.slug}.html (no-redirect)`);
    });
});
